= Ediary PHP Document =
lds <lds2012[at]gmail.com>
{localdate}

:language: php

.LOG
[width="100%"]
|====================================================================
|   Version     |       author      |       date        |       note
|   0.1         |       lds         |      2011-03-20   |        
|====================================================================

== application.ini 配置文件 ==

`/application/configs/application.ini`
全局配置文件.

复制 `application-sample.ini` 为 `application.ini` .

其中包括数据库等基本配置.

=== 参数 ===

.resources.db.params.host = "localhost"
数据库主机

.resources.db.params.username = ""
数据库帐号

.resources.db.params.password = ""
数据库密码

.resources.db.params.dbname = "eriji"
数据库名

.ediary.config.debug = "0"
    * "0" 关闭DEBUG
    * "1" 开启DEBUG

.ediary.config.logger.enable = "1"
    * "0" 关闭日志
    * "1" 开启日志

.ediary.config.logger.path = ""
日志文件绝对路径

.ediary.config.logger.type = "file"
日志类型: 
    * "file" : 日志储存到文件
    * "database" : 日志储存到数据库
    * "firebug" : 日志发送至firebug控制台

.ediary.config.installed = "0"
    * "1" 应用程序从未被安装
    * "0" 应用程序已经被安装


== autoLoad 命名方式 ==

module目录下的所有类名都使用 `Zend_Loader_Autoloader` , 命名方式为:
`Modulename_Model_Classname`

例如 `user` 模块下的名为 `User` 的类名如下:
`User_Model_User`


== magic quotes 魔法引号 ==

*魔法引号是被关闭的, 入库前必须注意安全性.*

关于为什么主动关闭魔法引号, 主要是考虑PHP今后的版本默认关闭魔法引号的特性.

所以入库都必须使用 `Zend_Db` 提供的 `quote` 或 `quoteInto` , 如果要对一次请求的所有POST或GET数组进行转义, 可以使用已封装好的内部魔法引号对一个数组进行转义:
[source]
----------------------------------------------
Ediary_Database_Db::addMagicQuotes($array);
----------------------------------------------
该方法会递归的对数组的 *值* 进行转义, 返回的数据可以安全入库.


== 数据安全性 ==

在 `Ediary` 库中的基本类几乎都没有对于数据进行验证,过滤(除了转义引号,防止SQL注入以外), 因为这个层面的设计是完全相信输入的数据, 不仅相信数据是非恶意的, 而且认定将会输入正确的数据(如不会输入不存在的field).

所以不要直接使用 *用户输入* 作为参数来直接调用这些类的公共方法, 用户是魔鬼.必须使用 `Controller` 作为这个底层和用户层的缓冲带, 验证/过滤用户传递来的所有数据(防止各种恶意/非正常输入). 

.FILTER INPUT, ESCAPE OUTPUT
    * Filter input : 推荐使用 `Zend_Filter_Input` .
    * Escape output: 推荐使用 `Zend_View->escape()` .


== Cache 缓存系统 ==

如果使用缓存系统, 缓存目录必须可读可写:
`/application/data/cache`


== Logger 日志系统 ==

使用日志系统,必须在配置文件中开启日志功能.

日志文件默认存储在:
`/application/log/log.txt`


== i18n 多国语言 ==

使用 `gettext` 实现多国语言支持, `mo` 文件集中储存在:
`/application/data/languages/`

默认语言为 `zh` .

在 `controller` 或 `view` 里都可以自动统一的翻译函数:
`echo _t("需要翻译的输出信息")`


== Testing 单元测试 ==

使用 `phpunit` 做单元测试. `phpunit.xml` 文件已经配置好所需的信息, 足够boot整个应用程序的基本环境, 即在测试里可以和正常环境下一样使用.

尽量保证每天最后一次提交代码前必须运行并通过所有单元测试, 不要遗留问题.

.运行所有测试:
转到 `/tests/` 目录下, 终端(命令行)下直接运行:
[source,bash]
---------------------
phpunit 
---------------------

.运行单个测试文件:
[source,bash]
--------------------------------------
phpunit --bootstrap bootstrap.php library/Ediary/Ediary_DiaryTest.php
--------------------------------------

NOTE: 必须加载 `bootstrap.php` ,该文件会boot起整个 `Zend Framework` 环境(依然是模拟环境,并非是真实的环境, 但足够进行各种测试)

== User 用户模块 ==

目前的 `Ediary_User` 和其他几个类有很大区别, 属于历史遗留问题, 使用的早期设计, 故没有和其他类使用统一的结构.

=== 新建用户 ===

新建用户时需要提供两个参数 `email` 和 `password` .

可以作为识别用户的只有 `id` 和 `email` , `name` 不能作为identification, 用户名只是作为一个显示, 而非识别, 可以是任意数字字符,甚至可以包括空格(兼容外国人名字).

大部分如 `Ediary_User->find($who)` 方法都提供了重载机制,即:
    * 当 `$who` 输入的为一串数字时, 则被识别输入的 `id` .
    * 当 `$who` 输入的是符合电子邮件格式的字符串时, 则被识别为 `email`.

NOTE: 不允许使用已经注册过的Email创建新用户, 前端会在输入时进行即时提示, 后端会直接拒绝(不会抛异常).

=== 用户验证 ===

=== Validate ===

当其他地方需要检验用户名/密码/电子邮箱的输入值是否合法时( `validate` ), 例如检查注册表单传递来的POST值, 可以直接条用静态方式:
[source]
-----------------------------------------
// return boolean
Ediary_User::isValidEmail($email);
Ediary_User::isValidUsername($name);
Ediary_User::isValidPassword($password);
-----------------------------------------

=== 判断用户是否存在 ===

`Ediary_User::isExists($who)`

=== 数据库原型 ===

用户在数据库中的主键是 `id` ,为一个自增长值.

`email` 为 `UNIQUE KEY` , 带索引并不允许重复.


== Diary Module ==

=== DoController ===

==== saveAction ====

使用 `Zend_Filter_StripTags` 对POST过来的diary content进行过滤, 没有使用html entity,是因为前端的tinyMCE对转义过的信息显示出来会直接显示HTML实体,而不是来浏览器上显示字符. stripTags 可以控制 allowTag , 所以对于XSS的预防还是有效的,不存在安全问题, 这是唯一的特例, 其他所以output都应该使用严格escape.

当 `$_POST['id']` 为 `-1` 时则认为是 `create` 动作, 否则都是 `update` .


== 重定向 ==

当访问不存在的控制器或动作时, 会重定向到 `default/error/error` 错误控制器做集中处理. 
    * 404:
    * 500:

.重定向:
    * 直接使用ZF提供的goSimple API
    * 使用倒计时重定向, 即先显示一个即将被重定向的倒计时页面,然后再重定向.

.倒计时重定向

原型:
`Ediary_Core::redirect($message, $title, $url)`

实例:
`$this->_redirect(Ediary_Core::redirect('登录成功', '首页', "/"));`


== Theme 样式布局 ==

样式应以简洁为主. 还原日记的本质, 靠近纸质书写的体验.

.layout
`/application/layouts/scripts/layout.phtml`
全局布局文件(HTML总结构).

.style
`/public/css`

.首页模板
`/application/modules/default/views/script/index/index.phtml`

== library 库 ==

根目录下的 `/library` 文件夹是自动设置到 `include_path` 里面的, 并且使用 `Zend frameword` 统一的命名约定.

=== Ediary ===

应用程序核心 `core` .


=== 第三方库 ===
    * http://code.google.com/p/zfdebug/[ZFDebug]


== TODO ==

    * 实现注册后,自动重定向/登录到编写日记页面. [3-20]
    * 为今后扩展考虑,决定引入tinyMCE作为编辑器的底层. [3-21]
        - 尝试将tinyMCE默认的theme复制后,替换theme name来新建一个主题,但是试了很多次,总是报 `q is not a constructor` 查明为在加载 theme 目录下的 `langs/en.js` 时url错误, `undefined/en/js` , 应该是theme的路径出错, 但是 `themeManager` 里面的 `urls` 列表里面是存在一个正确的URL的, 而且 `editor_template.js` 也可以正确的GET到.
        - 因为尝试新建主题失败,所以只有直接修改自带主题. 复制 `advanced` 主题下的 `default` skin为 `ediary` .
        - 暂时取消所有按钮,只保留tinyMCE编辑器本身, 今后再决定按钮如果加入.
    * 应该对页面也进行一定的单元测试.
    * 对前端JS进行性能测试, 检查是否有内存溢出.
    * 决定去掉日记中的两个内容:
        - 心情, 因为要去描述一天的心情不是件容易的事情.会出现很多时候都使用默认的一种心情(比如"一般"), 使得这个字段变得没有太多意义.
        - 天气, 前端取消天气的input,就是说用户不能去改变天气, 原因是天气是和日期关联的, 外部API可以将(日期/城市)转换为天气, 让用户去记录天气会造成操作的复杂, "你记,或者你不记,天气就在那里,不变不移".
    * 进行 `doSave` 这个动作前端和后端的协调.
    * `doSave` 动作前端单元测试.
    
首页-登录 -> today页面

单日记页面
今天写了日记(显示出来id=xxx)  || 今天没写日记(空白id=-1)

日记列表页面
分页查看

