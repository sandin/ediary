= Ediary PHP Document =
lds <lds2012[at]gmail.com>
{localdate}

:language: php

.LOG
[width="100%"]
|====================================================================
|   Version     |       author      |       date        |       note
|   0.1         |       lds         |      2011-03-20   |        
|====================================================================

== application.ini 配置文件 ==

`/application/configs/application.ini`
全局配置文件.

复制 `application-sample.ini` 为 `application.ini` .

其中包括数据库等基本配置.

=== 参数 ===

.resources.db.params.host = "localhost"
数据库主机

.resources.db.params.username = ""
数据库帐号

.resources.db.params.password = ""
数据库密码

.resources.db.params.dbname = "eriji"
数据库名

.ediary.config.debug = "0"
    * "0" 关闭DEBUG
    * "1" 开启DEBUG

.ediary.config.logger.enable = "1"
    * "0" 关闭日志
    * "1" 开启日志

.ediary.config.logger.path = ""
日志文件绝对路径

.ediary.config.logger.type = "file"
日志类型: 
    * "file" : 日志储存到文件
    * "database" : 日志储存到数据库
    * "firebug" : 日志发送至firebug控制台

.ediary.config.installed = "0"
    * "1" 应用程序从未被安装
    * "0" 应用程序已经被安装


== autoLoad 命名方式 ==

module目录下的所有类名都使用 `Zend_Loader_Autoloader` , 命名方式为:
`Modulename_Model_Classname`

例如 `user` 模块下的名为 `User` 的类名如下:
`User_Model_User`


== magic quotes 魔法引号 ==

*魔法引号是被关闭的, 入库前必须注意安全性.*

关于为什么主动关闭魔法引号, 主要是考虑PHP今后的版本默认关闭魔法引号的特性.

所以入库都必须使用 `Zend_Db` 提供的 `quote` 或 `quoteInto` , 如果要对一次请求的所有POST或GET数组进行转义, 可以使用已封装好的内部魔法引号对一个数组进行转义:
[source]
----------------------------------------------
Ediary_Database_Db::addMagicQuotes($array);
----------------------------------------------
该方法会递归的对数组的 *值* 进行转义, 返回的数据可以安全入库.


== 数据安全性 ==

在 `Ediary` 库中的基本类几乎都没有对于数据进行验证,过滤(除了转义引号,防止SQL注入以外), 因为这个层面的设计是完全相信输入的数据, 不仅相信数据是非恶意的, 而且认定将会输入正确的数据(如不会输入不存在的field).

所以不要直接使用 *用户输入* 作为参数来直接调用这些类的公共方法, 用户是魔鬼.必须使用 `Controller` 作为这个底层和用户层的缓冲带, 验证/过滤用户传递来的所有数据(防止各种恶意/非正常输入). 

.FILTER INPUT, ESCAPE OUTPUT
    * Filter input : 推荐使用 `Zend_Filter_Input` .
    * Escape output: 推荐使用 `Zend_View->escape()` .


== Cache 缓存系统 ==

如果使用缓存系统, 缓存目录必须可读可写:
`/application/data/cache`


== Logger 日志系统 ==

使用日志系统,必须在配置文件中开启日志功能.

日志文件默认存储在:
`/application/log/log.txt`


== i18n 多国语言 ==

使用 `gettext` 实现多国语言支持, `mo` 文件集中储存在:
`/application/data/languages/`

默认语言为 `zh` .

在 `controller` 或 `view` 里都可以自动统一的翻译函数:
`echo _t("需要翻译的输出信息")`


== Testing 单元测试 ==

使用 `phpunit` 做单元测试. `phpunit.xml` 文件已经配置好所需的信息, 足够boot整个应用程序的基本环境, 即在测试里可以和正常环境下一样使用.

尽量保证每天最后一次提交代码前必须运行并通过所有单元测试, 不要遗留问题.

.运行所有测试:
转到 `/tests/` 目录下, 终端(命令行)下直接运行:
[source,bash]
---------------------
phpunit 
---------------------

.运行单个测试文件:
[source,bash]
--------------------------------------
phpunit --bootstrap bootstrap.php library/Ediary/Ediary_DiaryTest.php
--------------------------------------

NOTE: 必须加载 `bootstrap.php` ,该文件会boot起整个 `Zend Framework` 环境(依然是模拟环境,并非是真实的环境, 但足够进行各种测试)

== User 用户模块 ==

目前的 `Ediary_User` 和其他几个类有很大区别, 属于历史遗留问题, 使用的早期设计, 故没有和其他类使用统一的结构.

=== 新建用户 ===

新建用户时需要提供两个参数 `email` 和 `password` .

可以作为识别用户的只有 `id` 和 `email` , `name` 不能作为identification, 用户名只是作为一个显示, 而非识别, 可以是任意数字字符,甚至可以包括空格(兼容外国人名字).

大部分如 `Ediary_User->find($who)` 方法都提供了重载机制,即:
    * 当 `$who` 输入的为一串数字时, 则被识别输入的 `id` .
    * 当 `$who` 输入的是符合电子邮件格式的字符串时, 则被识别为 `email`.

NOTE: 不允许使用已经注册过的Email创建新用户, 前端会在输入时进行即时提示, 后端会直接拒绝(不会抛异常).

=== 用户验证 ===

=== Validate ===

当其他地方需要检验用户名/密码/电子邮箱的输入值是否合法时( `validate` ), 例如检查注册表单传递来的POST值, 可以直接条用静态方式:
[source]
-----------------------------------------
// return boolean
Ediary_User::isValidEmail($email);
Ediary_User::isValidUsername($name);
Ediary_User::isValidPassword($password);
-----------------------------------------

=== 判断用户是否存在 ===

`Ediary_User::isExists($who)`

=== 数据库原型 ===

用户在数据库中的主键是 `id` ,为一个自增长值.

`email` 为 `UNIQUE KEY` , 带索引并不允许重复.


== Diary Module ==

=== DoController ===

==== saveAction ====

使用 `Zend_Filter_StripTags` 对POST过来的diary content进行过滤, 没有使用html entity,是因为前端的tinyMCE对转义过的信息显示出来会直接显示HTML实体,而不是来浏览器上显示字符. stripTags 可以控制 allowTag , 所以对于XSS的预防还是有效的,不存在安全问题, 这是唯一的特例, 其他所以output都应该使用严格escape.

当 `$_POST['id']` 为 `-1` 时则认为是 `create` 动作, 否则都是 `update` .


== 重定向 ==

当访问不存在的控制器或动作时, 会重定向到 `default/error/error` 错误控制器做集中处理. 
    * 404:
    * 500:

.重定向:
    * 直接使用ZF提供的goSimple API
    * 使用倒计时重定向, 即先显示一个即将被重定向的倒计时页面,然后再重定向.

.倒计时重定向

原型:
`Ediary_Core::redirect($message, $title, $url)`

实例:
`$this->_redirect(Ediary_Core::redirect('登录成功', '首页', "/"));`


== Theme 样式布局 ==

样式应以简洁为主. 还原日记的本质, 靠近纸质书写的体验.

.layout
`/application/layouts/scripts/layout.phtml`
全局布局文件(HTML总结构).

.style
`/public/css`

.首页模板
`/application/modules/default/views/script/index/index.phtml`


=== 分页 ===

默认使用封装了 `Zend_Paginator` 的 `Ediary_Paginator` 来进行分页, 配已模板系统则可以轻松的进行分页显示.

.原型
`Ediary_Paginator::factory($table, $where, $bind, $currentPageNumber = 1, $itemCountPerPage = 10)`

.例子
=======================================================
例如: 取得user id为3这个用户的第1页日记列表(按每页20篇分页).
[source]
-----------------------------------------
$paginator = Ediary_Paginator::factory('{diarys}', 'user_id = ?', 3, 1, 20);
---------------------------------------------------------
=======================================================

==== 参数 ====

.String $table
表名, 如果提供的表名带大括号, 则会自动添加表前缀.

.String $where
参考 `Zend_Db_Select` 的参数 `$where` .

.String|Array $bind
绑定到 `$where` 语句的参数, 参考 `Zend_Db_Select` 的参数 `$bind` .

.int $currentPageNumber = 1
当前页数, 参考 `Zend_Paginator` 的参数 `$currentPageNumber` . 注意: 如果提供的不是一个数字, 则会 *抛出异常* , 因为该值可能使用的是$_GET['page'] , 建议是对$_GET['page'] 进行检验和过滤, 不要直接传递GET值.

.int $itemCountPerPage = 10
每页显示的项目数量, 参考 `Zend_Paginator` 的参数 `$itemCountPerPage` .

==== 在视图中使用 ====

[source]
--------------------------------------------------------
<?php if (count($this->paginator)): ?>
<ul>
<?php foreach ($this->paginator as $item): ?>
  <li><?php echo $item; ?></li>
<?php endforeach; ?>
</ul>
<?php endif; ?>

<?php echo $this->paginationControl($this->paginator, 'Sliding', 'pagination_control.phtml'); ?>
                                   
--------------------------------------------------------

NOTE: 为复用考虑, 建议使用写好的独立模板来显示分页列表. 

== library 库 ==

根目录下的 `/library` 文件夹是自动设置到 `include_path` 里面的, 并且使用 `Zend frameword` 统一的命名约定.

=== Ediary ===

应用程序核心 `core` .


=== 第三方库 ===
    * http://code.google.com/p/zfdebug/[ZFDebug]


== TODO ==

    * 实现注册后,自动重定向/登录到编写日记页面. [3-20]
    * 为今后扩展考虑,决定引入tinyMCE作为编辑器的底层. [3-21]
        - 尝试将tinyMCE默认的theme复制后,替换theme name来新建一个主题,但是试了很多次,总是报 `q is not a constructor` 查明为在加载 theme 目录下的 `langs/en.js` 时url错误, `undefined/en/js` , 应该是theme的路径出错, 但是 `themeManager` 里面的 `urls` 列表里面是存在一个正确的URL的, 而且 `editor_template.js` 也可以正确的GET到.
        - 因为尝试新建主题失败,所以只有直接修改自带主题. 复制 `advanced` 主题下的 `default` skin为 `ediary` .
        - 暂时取消所有按钮,只保留tinyMCE编辑器本身, 今后再决定按钮如果加入.
    * 应该对页面也进行一定的单元测试.
    * 对前端JS进行性能测试, 检查是否有内存溢出.
    * 决定去掉日记中的两个内容:
        - 心情, 因为要去描述一天的心情不是件容易的事情.会出现很多时候都使用默认的一种心情(比如"一般"), 使得这个字段变得没有太多意义.
        - 天气, 前端取消天气的input,就是说用户不能去改变天气, 原因是天气是和日期关联的, 外部API可以将(日期/城市)转换为天气, 让用户去记录天气会造成操作的复杂, "你记,或者你不记,天气就在那里,不变不移".
    * 进行 `doSave` 这个动作前端和后端的协调.
    * `doSave` 动作前端单元测试.
    * 决定取消 *日记本* 这个概念, 原因是: 任何一个人都不可能同时使用两个日记本来写日记, 而是使用完一个再使用另一个, 如果通过积分来决定用户是否有权限来开启另一个新的日记本, 假设增加积分只有两种可能:1.是充值;2.是写日记. 也就是说如果通过写一篇日记就可以增加一个积分的话, 那么在用户写完一本日记后, 肯定会有足够的积分来开启另一个日记本, 因此该积分制度并没有用处, 因为如果用户没有写完一本日记的话, 他也不会需要开启另一个日记本. 如果积分是一种增值方式, 需要购买才能开启另一个日记本的话, *写日记* 是本程序的基本功能, 而不应该是增值项目. 分日记本的唯一好处是 *分类* , 比如一个日记本就是一年的日记之类的, 那么就应该把日记本视作一种 *分类* .  而日记唯一需要进行的分类就是按月/季/年等方式, 比如用户需要查看一个某年的所有日记, 所以这里需要的 *分类* 概念又实际上是 *归档* ,按日期进行归档, 而这种归档完全可以根据日记的自带时间来进行, 而不需要另外的表来存储相关信息. 且更为灵活.
    * 实现日记列表, 新建统一的分类模板函数 . theme, page.
    * 决定将日记列表从 *标题列表* 改成 *标题/内容列表* ,  因为标题基本都是日期, 列出来没有多少意义, 而使用类似博客的形式把日记都分页列出来, 才更方便进行回顾性的浏览, 然后单日记浏览功能也需要实现.
    * 参考豆瓣, AUTO_INCREMENT = 10000000

    首页-登录 -> today页面

.单日记页面伪代码
[source]
----------------------------------------------------------
if (指定了id) {
    打开某个特定的日记, 根据GET的ID选择显示内容
    $diary = getbyid(id);
    // 检查diary->user_id 是否等于当前用户ID, 否则显示"无权限"
} else {
    查询今天的日记
    $diarys = getbyData(today, user_id);
    if (今天写了日记) {
        显示出来id=xxx;
        $diary = getbyid(id);
    } else {
        今天没写日记, 显示空白编辑器(空白id=-1)
        $diary = new Diary(id = -1);
    }
}
----------------------------------------------------------

日记列表页面
分页查看

.router

单日记页面
/diary/ 今天的日记
/diary/1000000 某个特定的日记

日记列表
/diary/list
/diary/list/page/2 

